### 作用域（在学习之后做50道类似的题，弄明白就通了）
    - 指的是js运行的范围

    - 作用域分为2种，一种叫全局作用域，另一种叫局部作用域

- 全局作用域:
```  
    当打开浏览器解读到script标签的时候，会把js运行在一个window的全局作用域下,
    全局会生成一个全局的活动变量对象，会把所有的变量或者函数设置为这个对象下属性，整个window下的环境都叫全局作用域；所以一个变量或者一个函数，默认属于window。


    console.log(window.a); //如果没有使用var声明变量，在赋值之前是不会把a挂在window上的，所以a是找不到的
    a = 10;
    console.log(window);//赋值之后window下就有a
```


- 局部作用域:
    ```
        在运行函数的时候，函数内部会开辟一个执行栈，在执行栈中会创建一个活动变量的对象，会把函数中所有变量、函数存储到这个活动变量下，执行栈去运行这个活动变量，这些活动变量下的变量、函数***只会作用在函数内***这种现象就叫局部作用域


    作用域链:
        如果函数内访问不到某个变量，先去参数中找，还找不到会向父级函数查找，直到window全局，如果还找不到就报错

    - 局部作用域运行:
        1.没有形参的时候，但是有var 如果在var的上方访问这个变量，结果是undefined

        2.有形参并且也有实参也有var 如果在var的上方访问这个变量，结果应该是实参

        3.如果函数内有函数，有形参并且也有实参，那么结果就为函数内有函数
    
    ```

- 变量提升(预解析机制):
        当浏览器去解析js的时候，会提前解析全局的变量和函数的过程。

    解读代码的时候一定要记住以下两步:
    第一步:
        上来就找var和function声明

    第二步:
        逐行解读代码，此时var和function声明就不用再去读了，
        一般读的是赋值(=)，计算，输出，判断..

PK规则:
    变量没有函数大，后面的函数声明比前面的函数声明大(后面的函数声明会覆盖前面的函数声明)

    ```
        /*
            一个匿名函数自执行函数，如果带有名字，在函数体内不管如何赋值同名的变量，结果都等于这个有名函数。
        */
        var a = 10;
        (function a(){
            a = {};
            console.log(a); //还是a函数代码块
        })();

    ```

### var、let、const
    ``` 
        var 变量
            变量提升，存入到全局的活动变量对象中,允许有多个同名的变量，不支持块级作用域

        let 变量
            不会变量提升且有暂存死区(在变量定义的上方都访问不到这个变量)
            不会存入到全局的活动变量对象中
            不允许有多个同名的变量
            支持块级作用域

        const 常量
            不会变量提升且有暂存死区(在变量定义的上方都访问不到这个变量)
            不会存入到全局的活动变量对象中
            不允许有多个同名的变量
            值是不能被改变的（引用类型可以改变属性值）
            声明了必须赋值
    ```

块级作用域:
    {
        console.log(a); //在上方访问块中的函数a，结果undefined
        if(a){
            console.log(1)
        }else{
            console.log(2)
        }
        {
            //这个函数在块中，在预解析的时候会undefined
            function a(){}
        }
        console.log(a);
    }





