<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<script>

    /*
        let {key1,key2} = {key1:val1,key2:val2}

        在声明的时候使用块声明，块中放对象的key值，这里的key值一定要
        和解构对象的key值名字要一致

        如果要取别名，使用:新定义的名字即可
            let {key1:k,key2} = {key1:val1,key2:val2}

        此时key1已经访问不到了，要访问就报错，只能访问k，k就代表key1，
        名字跟声明变量规则一致

        如果加了:不报错，那么可以先解构一次，再重命名
            let {
                f,  //先把f解构出来，这样就可以访问f了
                f:x
            } = {
               f:{
                    name:'11',
                    age:22
               }
            }

    */
    let objhdjksdjks = {
        type: "sug", 
        sa: "s_2",
        q: "猪肉为什么涨价厉害",
        s:"某炎生杀母猪"
    }    

    // let {type:t,q,s} = objhdjksdjks;
    // console.log(type,q,s);
    // console.log(t);

    // console.log(objhdjksdjks.type);
    // console.log(objhdjksdjks.q);
    // console.log(objhdjksdjks.s);

    // console.dir(console);

    // let {log,dir} = console;

    // log(1);

    // let obj = {
    //     p: [
    //         'Hello',
    //         {
    //             y: 'World',
    //             z:{
    //                 x:[
    //                     {
    //                         j:0
    //                     }
    //                 ]
    //             }
    //         }
    //     ]
    // };
    // let {p:[x,{y,z:{x:[{j}]}}]} = obj

    // console.log(j);


    // const node = {
    //     loc: {
    //         start: {
    //             line: 1,
    //             column: 5
    //         }
    //     }
    // };

    // let { loc, loc: { start }, loc: { start: { line }} } = node;

    // console.log(line);


    // let {
    //     f,
    //     f:x
    // } = {
    //     f:{
    //         name:'11',
    //         age:22
    //     }
    // }

    // console.log(f)


    // let obj = {};
    // let arr = [];
    //foo->123  -> obj.prop = 123 
    // ({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });

    // console.log(obj,arr);
    // obj.prop = {}.foo;

    // var {x, y = 5} = {x: 1};
    // console.log(x,y);

    // let {value:val} = input


    // function fn({age:{b}}){
    //     // obj.age.b
    //     console.log(b);
    // }

    // fn({name:'haha',age:{s:1,b:2}})


    // function move({x, y} = { x: 0, y: 0 }) {
    //     return [x, y];
    // }
    /**
        传了对象那么就按照传的对象来解析，不会按照默认的来解析 
    **/
    const {log} = console;
    // log(move({x: 3, y: 8}));  //3,8
    // log( move( {x: 3} )); //3,undefined
    // log( move({}));//undefined,undefined
    // log(move());//0,0


    // log([1, undefined, 3].map((item='yes') => item) );




</script>
</body>
</html>